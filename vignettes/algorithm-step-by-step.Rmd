---
title: "Generate a standard load profile"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Generate a standard load profile}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

``` {r, message=FALSE, include=FALSE}
library(standardlastprofile)
library(ggplot2)
```

The aim of this vignette is to show how the algorithm of the `slp_generate()` function works step by step. The data in the `slp` dataset forms the basis for all subsequent steps. There are 96 x 1/4 hour measurements of electrical power for each combination of `profile_id`, `period` and `day`, which we refer to as the "standard load profile". The data was determined in 1999 on the basis of 1,209 measured load profiles of low-voltage customers in Germany[^bdew-1].

  [^bdew-1]: More detail on the data and methodology can be found [here](https://www.bdew.de/media/documents/1999_Repraesentative-VDEW-Lastprofile.pdf).

Those measurements are normalized to an annual consumption of 1,000 kWh. So if we sum up all the quarter-hour consumption values for a year, the result is (approximately) 1,000 kWh/a.

```{r H0_data, message=FALSE}
library(standardlastprofile)
H0_2024 <- slp_generate(
  profile_id = "H0",
  start_date = "2024-01-01",
  end_date = "2024-12-31"
  )
```

```{r normalization-1, message=FALSE}
sum(H0_2024$watts)
```

"Hold on - didn't you just say 1,000?!", you might be thinking. Yes you are correct, we must [convert power units into energy units](https://en.wikipedia.org/wiki/Watt#Distinction_between_watts_and_watt-hours). The values returned are 1/4h measurements in watts. To convert the values to watt-hours, we must hence divide them by 4; and since one watt-hour is equal to 1/1000 kilowatt-hour, we divide also by 1,000:

```{r normalization-2, message=FALSE}
sum(H0_2024$watts / 4 / 1000)
```

## Algorithm step by step

When you call `slp_generate()` you generate a standard load profile given one, or more profile identifiers. These are the steps that are performed:

1. Generate a date sequence from `start_date` to `end_date`
2. Map each day to combination of `day` and `period`
3. Use result from 2nd step to extract values from `slp`[^data-1]

    [^data-1]: That is actually a lie. There is an internal data object from which the data is extracted for effiecency.

4. Apply polynomial function to values of profile identifier `H0`
5. Return data[^bdew-2]

  [^bdew-2]: More detail on the algorithm can be found [here](https://www.bdew.de/media/documents/2000131_Anwendung-repraesentativen_Lastprofile-Step-by-step.pdf){:target="_blank"}.

  
### Generate a date sequence

In the very first step a date sequence is created from `start_date` to `end_date` based on the user input. Here is a simple example; the result is a vector of class Date:

```{r date_seq-1, message=FALSE, echo=TRUE}
(date_seq <- seq.Date(as.Date("2023-12-22"), as.Date("2023-12-27"), by = "day"))
```

### Map each day to a period and a weekday

The study found that consumption varies both over the course of the year and over the days within a week when analyzing 1,209 measured load profiles of low-voltage customers. The definition of periods is:

* `summer`: May 15 to September 14
* `winter`: November 1 to March 20
* `transition`: March 21 to May 14, and September 15 to October 31

However, it was also found that there was no significant difference in consumption between Monday and Friday for any group. For this reason, the days Monday to Friday are grouped together as 'workdays'. December 24th and 31th are considered a Saturday too, if they are not a Sunday, and public holidays are set to a Sunday.

*Note*: The package standardlastprofile supports only public holidays for Germany. Those were retrieved from the [nager.Date API](https://github.com/nager/Nager.Date) and below are listed nationwide holidays for 2024:

* Jan 1: New Year's
* Mar 29: Good Friday
* Apr 1: Easter Monday
* May 1: Labor Day
* May 9: Ascension Day
* May 20: Whit Monday
* Oct 3: German Unity Day
* Dec 25: Christmas Day
* Dec 26: Boxing Day

The result of this second step is a mapping from each date to a so-called characteristic profile day, i.e. a combination of weekday and period:

```{r characteristic_days, message=FALSE}
wkday_period <- standardlastprofile:::get_wkday_period(date_seq)
data.frame(date = date_seq, day = wkday_period)
```

### Assign consumption values to each day

The third step is to assign the measurements we know from the `slp` dataset to each characteristic profile day. This is the job of the `slp_generate()` function:

``` {r G5_data_vignette, echo=TRUE}
G5 <- slp_generate(
  profile_id = "G5",
  start_date = "2023-12-22",
  end_date = "2023-12-27"
  )
```

It was found that the load fluctuations for commercial and agricultural customers are moderate. That is, for for customers/customer groups `G0` to `G6`, and `L0` to `L2` the standard load profile can be determined directly from the 3x3 characteristic profile days. Here is the code to reproduce the plot for profile `G5` from the [README](https://github.com/flrd/standardlastprofile#generate-a-load-profile), where we can see the result of the algorithm:

``` {r G5_plot_vignette, echo=TRUE, eval=TRUE, message=FALSE, fig.retina=2, fig.asp=0.5}
#| fig.alt = "Line plot of the BDEW standard load profile 'G5' (Bakery
#|  with a bakehouse) from December 22nd to December 27th 2023; values 
#|  are normalized to an annual consumption of 1,000 kWh."
library(ggplot2)
ggplot(G5, aes(start_time, watts)) +
  geom_line(color = "#0CC792") +
  scale_x_datetime(
    date_breaks = "1 day",
    date_labels = "%b %d") +
  labs(
    title = "'G5': bakery with bakehouse",
    subtitle = "1/4h-measurements, based on consumption of 1,000 kWh/a",
    caption = "data: www.bdew.de",
    x = NULL,
    y = "[watts]") +
  theme_minimal() +
  theme(
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank()
  ) +
  NULL
```

As you can see, in 2023 the values are the same for December 24th, 2024 (a Sunday), December 25th, and 26th (both public holidays).

### Generate a dynamic load profile 

In contrast to most commercial and agricultural businesses, which have a relatively even and a fairly constant power consumption over the course of a year, households on the other hand have a continuously decreasing electricity consumption from winter to summer  (in Germany), et vice versa. This fact is taken into account when you call `slp_generate()`. The study suggested the application of a 4th order polynomial function to the electric power values of profile identifier `H0`:

$$
x = x_0 \times(-3.92\mathrm{e}{-10} \times d^4 + 3.20\mathrm{e}{-7} \times  d^3 - 7.02\mathrm{e}{-5} \times d^2 + 2.10\mathrm{e}{-3} \times d + 1.24)
$$
Where:

* $x$ is the resulting 'dynamic' quarter-hour value
* $x_0$ is the static quarter-hourly value
* $d$ is the day of the year as integer, starting at 1 on January 1st

The following plot shows how the electrical power develops over the year for the profile identifier `H0`. For a clearer picture, the values are aggregated at daily level:

``` {r H0_2024_daily, message=FALSE, echo=FALSE, fig.retina=2, fig.asp=0.5}
# aggregate by day of year as decimal number (1 - 365)
H0_2024_daily <- by(H0_2024, INDICES = format(H0_2024$start_time, "%j"), FUN = function(x) {
  data.frame(
    start_time = x[["start_time"]][1],
    watts = mean(x[["watts"]])
  )
})
H0_2024_daily <- do.call(rbind, args = H0_2024_daily)
```


``` {r H0_2024_plot, message=FALSE, echo=FALSE, fig.retina=2, fig.asp=0.5}
#| fig.alt = "Line plot of standard load profile 'H0' (households)
#|  aggreagted by day from January 1st to December 31st, 2023. The plot shows that  
#|  households have a continuously decreasing load from winter 
#|  to summer and vice versa."
ggplot(H0_2024_daily, aes(start_time, watts)) +
  geom_line(color = "#0CC792") +
  labs(title = "Profile 'H0': Households",
       subtitle = "Electrical power per day",
       caption = "data: www.bdew.de",
       x = NULL,
       y = "[watts]") +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  NULL
```



``` {r dynamization_fun, message=FALSE, eval= FALSE, echo=FALSE, fig.retina=2, fig.asp=0.5}
ggplot(data.frame(day_of_year = seq.int(365)), aes(day_of_year)) +
         geom_function(fun = standardlastprofile:::dynamization_fun,
                       color = "#0CC792") +
  labs(title = "Dynamization Function applied to values of load profile H0",
       x = "Day of Year as Integer",
       y = NULL) +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank()
  )
```
