---
title: "Generate a standard load profile"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Generate a standard load profile}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

``` {r, message=FALSE, include=FALSE}
library(standardlastprofile)
library(ggplot2)
```

Standard load profiles are crucial for electricity providers, grid operators, and 
the energy industry as a whole. They aid in planning and optimizing the demand 
for electricity generation and distribution. Additionally, they serve as the foundation for billing and balancing electricity quantities in the energy 
market. For smaller consumers, the financial expense of continuous consumption measurement is often unreasonable. Energy supply companies can therefore use a standard load profile as the basis for creating a consumption forecast.

The aim of this vignette is to show how the algorithm of the `slp_generate()` 
function works.[^bdew-1] The data in the `slp` dataset forms the basis for all subsequent steps. 

  [^bdew-1]: More information on the algorithm can be found [here](https://www.bdew.de/media/documents/2000131_Anwendung-repraesentativen_Lastprofile-Step-by-step.pdf)

``` {r, message=FALSE}
head(slp)
```

There are 96 x 1/4 hour measurements of electrical power for each unique combination of `profile_id`, `period` and `day`, which we refer to as the "standard load profile". The data was collected and analyzed in 1999 on the basis of 1,209 measured load profiles of low-voltage customers in Germany and is provided by German Association of Energy and Water Industries[^bdew-2] (BDEW Bundesverband der Energie- und Wasserwirtschaft e.V.).

  [^bdew-2]: More information on the data and methodology can be found [here](https://www.bdew.de/media/documents/1999_Repraesentative-VDEW-Lastprofile.pdf).
  
```{r small_multiples_vignette, echo = FALSE, fig.asp = 1.4, fig.retina=2}
#| fig.alt = "Small multiple line chart of 11 standard load profiles
#|  published by the German Association of Energy and Water Industries (BDEW 
#|  Bundesverband der Energie- und Wasserwirtschaft e.V.). The lines compare
#|  the consumption for three different periods over a year, and
#|  also compare the consumption between different days of a week."

# labeller
label_names <- c(
  "saturday" = "Saturday",
  "sunday" = "Sunday",
  "workday" = "Workday"
)

label_fun <- function(x) label_names[[x]]

# plot
ggplot(slp,
       aes(x = as.POSIXct(x = paste(Sys.Date(), timestamp)),
           y = watts,
           color = period)) +
  geom_line() +
  facet_grid(profile_id ~ day,
             scales = "free_y",
             labeller = labeller(day = as_labeller(label_names))) +
  scale_x_datetime(NULL, date_breaks = "6 hours", date_labels = "%H:%M") +
  scale_y_continuous(NULL) +
  scale_color_manual(name = NULL,
                     values = c(
                       "winter" = "#961BFA",
                       "summer" = "#FA9529",
                       "transition" = "#0CC792"
                       )) +
  labs(title = "Standard Load Profiles",
       subtitle = "96 x 1/4h measurements a day [in watts], based on consumption of 1,000 kWh/a",
       caption = "data: www.bdew.de") +
  theme_minimal() +
  theme(legend.position = "top") +
  theme(strip.text.y.right = element_text(angle = 0)) + 
  theme(
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank()
  ) +
  # theme(axis.text.y = element_blank()) +
  NULL
```


Those measurements are normalized to an annual consumption of 1,000 kWh. So, if we sum up all the quarter-hour consumption values for a year, the result is (approximately) 1,000 kWh/year.

```{r H0_data, message=FALSE}
library(standardlastprofile)
H0_2024 <- slp_generate(
  profile_id = "H0",
  start_date = "2024-01-01",
  end_date = "2024-12-31"
  )
```

```{r normalization-1, message=FALSE}
sum(H0_2024$watts)
```

'Hold on - didn't you just say 1,000?!' you might be thinking. Yes, you are correct; we must [convert power units into energy units](https://en.wikipedia.org/wiki/Watt#Distinction_between_watts_and_watt-hours). The values returned are 1/4-hour measurements in watts. To convert the values to watt-hours, we must, therefore, divide them by 4. Since one watt-hour is equal to 1/1000 kilowatt-hour, we also divide by 1,000:

```{r normalization-2, message=FALSE}
sum(H0_2024$watts / 4 / 1000)
```

## Algorithm step by step

When you call `slp_generate()`, you (surprise!) generate a standard load profile given a profile identifier, whereby several profile identifiers are supported simultaneously. These are the steps that are then performed:

1. Generate a date sequence from `start_date` to `end_date`.
2. Map each day to combination of `day` and `period`.
3. Use result from 2nd step to extract values from `slp`.[^data-1]

    [^data-1]: That is actually a lie. There is an internal data object from which the data is extracted for effiecency.

4. Apply polynomial function to values of profile identifier `H0`.
5. Return data.
  
### Generate a date sequence

In the initial step, a date sequence is created from `start_date` to `end_date` based on the user input. Here's a simple example:

```{r date_seq-1, message=FALSE, echo=TRUE}
start <- as.Date("2023-12-22")
end <- as.Date("2023-12-27")

(date_seq <- seq.Date(start, end, by = "day"))
```

### Map each day to a period and a weekday

The measured load profiles analyzed in the study showed that electricity 
consumption across all groups fluctuates both over the period of a year and
over the days within a week. The `period` definition is:

* `summer`: May 15 to September 14
* `winter`: November 1 to March 20
* `transition`: March 21 to May 14, and September 15 to October 31

It was also found that there was no significant difference in consumption on 
weekdays from Monday to Friday for any group. For this reason, the days Monday
to Friday are grouped together as 'workdays'. December 24th and 31st are 
considered Saturdays too if they are not Sundays. Public holidays are regarded as Sundays.

*Note*: The package standardlastprofile supports only public holidays for 
Germany. Those were retrieved from the 
[nager.Date API](https://github.com/nager/Nager.Date). Below are 
nationwide holidays for 2024:

* Jan 1: New Year's
* Mar 29: Good Friday
* Apr 1: Easter Monday
* May 1: Labor Day
* May 9: Ascension Day
* May 20: Whit Monday
* Oct 3: German Unity Day
* Dec 25: Christmas Day
* Dec 26: Boxing Day

There is an optional argument `state_code` that can take one of 16 
[ISO 3166-2:DE](https://en.wikipedia.org/wiki/ISO_3166-2:DE) codes representing 
a German state. This allows you to consider holidays that are
defined at the state level too.

The result of this second step is a mapping from each date to a so-called
characteristic profile day, i.e. a combination of weekday and period:

```{r characteristic_days, message=FALSE}
wkday_period <- standardlastprofile:::get_wkday_period(date_seq)
data.frame(input = date_seq, output = wkday_period)
```

### Assign consumption values to each day

The third step is to assign the measurements we know from the `slp` dataset to
each characteristic profile day. This is the job of the `slp_generate()` function:

``` {r G5_data_vignette, echo=TRUE}
G5 <- slp_generate(
  profile_id = "G5",
  start_date = "2023-12-22",
  end_date = "2023-12-27"
  )
```

This function returns a data frame with 4 columns:

```{r}
head(G5)
```

The data analysis revealed that load fluctuations for both commercial and agricultural customers remain moderate throughout the year. Specifically, for customers and customer groups labeled as `G0` to `G6`, and `L0` to `L2`,the standard load profile can be accurately derived directly from the 3x3 characteristic profile days available in the dataset  `slp`.

Below is the code snippet from the [README](https://github.com/flrd/standardlastprofile#generate-a-load-profile), 
which can be used to reproduce the plot for the G5 profile, showcasing the 
algorithm's outcome:

``` {r G5_plot_vignette, echo=TRUE, eval=TRUE, message=FALSE, fig.retina=2, fig.asp=0.5}
#| fig.alt = "Line plot of the BDEW standard load profile 'G5' (Bakery
#|  with a bakehouse) from December 22nd to December 27th 2023; values 
#|  are normalized to an annual consumption of 1,000 kWh."
library(ggplot2)
ggplot(G5, aes(start_time, watts)) +
  geom_line(color = "#0CC792") +
  scale_x_datetime(
    date_breaks = "1 day",
    date_labels = "%b %d") +
  labs(
    title = "'G5': bakery with bakehouse",
    subtitle = "1/4h-measurements, based on consumption of 1,000 kWh/a",
    caption = "data: www.bdew.de",
    x = NULL,
    y = "[watts]") +
  theme_minimal() +
  theme(
      panel.grid.minor.x = element_blank(),
      panel.grid.minor.y = element_blank()
  ) +
  NULL
```

As you can see, the values in 2023 for December 24 (a Sunday) and 
December 25 and 26 (both public holidays) are identical.

### Special case: H0

In contrast to most commercial and agricultural businesses, which have a 
relatively even and constant electricity consumption throughout the year, 
household electricity consumption decreases from winter to summer and 
vice versa (at least in Germany). This is taken into account when you call `slp_generate()`. The study suggested the application of a 4th order polynomial function to the electric power values of profile identifier `H0`. 

$$
x = x_0 \times(-3.92\mathrm{e}{-10} \times d^4 + 3.20\mathrm{e}{-7} \times  d^3 - 7.02\mathrm{e}{-5} \times d^2 + 2.10\mathrm{e}{-3} \times d + 1.24)
$$
Where:

* $x$ is the resulting 'dynamic' quarter-hour value
* $x_0$ is the static quarter-hourly value
* $d$ is the day of the year as integer, starting at 1 on January 1st

The values given for profile H0 are only characteristic calculation values. Only
through multiplication with the 4th order polynomial function does it become a 
representative and - as it is called in the study - dynamized load profile for 
the group of household customers.

The following plot shows how the electrical power develops over the year for 
the profile identifier `H0`; for a clearer picture, the values are aggregated 
at daily level:

``` {r H0_2024_daily, message=FALSE, echo=FALSE, fig.retina=2, fig.asp=0.5}
# aggregate by day of year as decimal number (1 - 365)
H0_2024_daily <- by(H0_2024, INDICES = format(H0_2024$start_time, "%j"), FUN = function(x) {
  data.frame(
    start_time = x[["start_time"]][1],
    watts = mean(x[["watts"]])
  )
})
H0_2024_daily <- do.call(rbind, args = H0_2024_daily)
```


``` {r H0_2024_plot, message=FALSE, echo=FALSE, fig.retina=2, fig.asp=0.5}
#| fig.alt = "Line plot of standard load profile 'H0' (households)
#|  aggregated by day from January 1st to December 31st, 2023. The plot shows that  
#|  households have a continuously decreasing load from winter 
#|  to summer and vice versa."
ggplot(H0_2024_daily, aes(start_time, watts)) +
  geom_line(color = "#0CC792") +
  labs(title = "Profile 'H0': Households",
       subtitle = "Electrical power per day",
       caption = "data: www.bdew.de",
       x = NULL,
       y = "[watts]") +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  NULL
```

Use data at your own caution. Feel free to 
[create an issues](https://github.com/flrd/standardlastprofile/issues) and 
suggest improvements.



``` {r dynamization_fun, message=FALSE, eval= FALSE, echo=FALSE, fig.retina=2, fig.asp=0.5}
ggplot(data.frame(day_of_year = seq.int(365)), aes(day_of_year)) +
         geom_function(fun = standardlastprofile:::dynamization_fun,
                       color = "#0CC792") +
  labs(title = "Dynamization Function applied to values of load profile H0",
       x = "Day of Year as Integer",
       y = NULL) +
  theme_minimal() +
  theme(
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank()
  )
```
